# 22-10-06

## 과제

### 4
it분야는 특히 스스로 공부하는 능력이 중요

### 5
보안공부의 기본
코드를 보는 능력을 기른다

### 6

### 7
이번 과제를 열심히 하면 중간에 엄청 큰 도움이 될 것이다

### 9
함수를 호출하고 스택이 어떻게 동작하는지 알아야된다

### 10
언본 소스와 어셈블리 코드에 버퍼 오버플로우를 확인

### 11

### 12
레지스터 찾아보기

### 13
그림의 코드를 이해할 수 있어야 한다

### 14

### 15

### 16
gdb를 더 편하게 하는 도구
훨씬 편함
다양한 정보 제공

### 17

### 18
메모리 보호 기법 중 하나가 마지막 보너스문제에 적용돼 있다

### 19
기초지만 어려울 것이다

### 21
개인적으로 가지고 있는 환경을 가지고 있다면 따로 해도된다

### 22

### 23

### 24

### 25
exercise는 보고서 작성 필요 없음
bof1.c - 64비트로 컴파일됨

### 26

### 27
64비트로 컴파일됨

### 28

### 29
32비트 컴파일됨
메모리 보호 기법이 적용됨
이것을 우회해야함

### 32

### 33

### 34

## 커널 및 예외 사항

### 3

### 4
운영체제는 구분할 수 있어야 한다 허용에 대해

### 5
쉐어드 라이브러리
- 시스템 서비스가 필요할 때 시스템 콜을 이용한다
표준 유틸리티
- 실행 가능한 파일
- 라이브러리 함수를 호출
- 하드웨어 접근이 필요할 때 라이브러리를 거지거나 거치지 않고 시스템 콜
커널 모드
- cpu가 운영체제 코드를 수행할 때
- 권한이 높다 -> 특권
- 모든 명령어들을 수행 가능
유저 모드
- 운영체제 위의 코드를 수행할 때
- 특권 레벨의 명령은 직접적으로 실행 불가 -> 시스템 콜을 통해 운영체제에게 간접적으로 요청

### 6
모두 한번씩 사용해봐야 하는 명령어

### 7
윈도우
- 루트 유저 = 수퍼유저 , 관리자 유저
리눅스
- su와 sudo의 차이점
운영체제에서 커널이 뭐지?
- 커널 모듈과 유저 프로그램 차이점
- 커널의 기능
유저모드와 커널모드 차이점은?
멀웨어
- 커널레벨의 멀웨어가 왜 더 심각?
- e.g. 루트킷은 커널 모드와 유저 모드가 있다, 커널 모드가 더 위험
시스템 콜과 라이브러리 펑션 콜 차이점

### 8
전동적인 관점의 OS
아래쪽이 OS 커널
- 시스템 콜이 문제가 없다 -> 특권으로 시스템 명령어 사용 -> 함수 리턴 후 사용자 프로세스로 제어 돌아감
- 컴퓨터 자원은 여러개의 프로세스가 공유
- 공유 자원 사용 요청에 대해 중재, 통제
- 어떤 프로세스는 비의도적으로 또는 악의적으로 비정상적인 작동 가능 -> 커널 코드와 데이터는 비신뢰 프로세스로부터 보호
위는 사용자 프로세스 
- 각 프로세스는 가상적인 주소 공간
- 각 주소 공간에 하나 이상의 쓰레드 존재
- 특권 명령 권한 없다 -> 하드웨어 접근이 필요할 때는 허용된 시스템콜로 운영체제에게 요청

### 9
프로세스
- 능동적인 개체
- 실행되는 단위
- 실행중인 프로그램
- 각 프로세스는 가상주소 공간을 가짐
- 하나 이상의 쓰레드
- PCB, TCB 형태로 커널에서 관리
- 데이터와 코드 참조
- PC가 다음 실행 코드의 주소 포인트
- 
가상주소공간
- 어떤 프로세스에 대한 문맥(하드웨어 실행에 필요한 문맥, 시스템 콜에 필요한 문맥, ..)
- 한 프로세스가 참조할 수 있는 데이터와 코드의 잡합
- 오픈한 파일에 대해 접근하기 위한 정보
커널
- 하드웨어를 직접적으로 통제하는 소프트웨어 구성 요소
- 인터럽트 처리, 시피유 스케줄링, 인터프로세스커뮤니케이션, 폴크, 시스템콜
- 특권을 가지고 실행
- 모든 명령 실행 가능
- 신뢰되지 않는 코드로부터 보호
- 커널이 보호받을 수 있도록 하드웨어 레벨에서도 지원
- 컴퓨터 하드웨어에 대해 통제와 제어
파일
- 어떤 정보가 디스크에 저장되는 단위
- 정보를 담고 있는 주요 객체
- 유닉스에서 모든 객체, 디바이스, 파이프, 소켓 등 모두 파일로 취급

## 유저모드 커널모드

### 11
커널
- 시스템에 있는 모든것을 통제, 관리, 감독
- 중요한 자원, 하드웨어에 접근할 때 사용자는 커널에게 요청 -> 요청이 적합하면 빨리 처리 -> 메모리에 항상 상주
- 안전하게 보호
- 하드웨어적으로 보호
- 사용자 프로그램이 하드웨어 서비스를 직접 이용 원할 때 시스템 콜을 이용 -> 요청이 타당하면 처리
커널 기능
- 시피유 스케줄링
- 문맥 교환
- 인터프로세스커뮤니케이션
- 버츄얼어드레스를 피지컬어드레스로
- 예외처리
두가지 모드 연산 제공
- 유저 모드
    - 사용자 앱과 라이브러리의 코드, 프로세스
- 커널 모드
    - 시스템 콜에 의한 명령들

### 12
시피유 모드
- 상태 레지스터가 시피유가 어떤 상태인지 나타냄 -> 모드
커널은 보호되는 영역
커널모드에서만 어떤 명령어와 레지스터를 접근 가능 -> 유저 모드에서 특권없이는 접근 불가 명령어와 레지스터 존재
사용자모드에서 커널로
- 시스템 콜 -> 트랩 -> 모드 전이
- 폴트 : e.g.디바이드 바이 제로, 폴트 이후 자원회수 정리 커널에서
- 인터럽트 : e.g. 시피유 스케줄링에서 라운드로빈, 타임슬라이싱, 타임쉐어링 등으로 타임아웃 -> 타임 인터럽트 -> 문맥교환 -> 유저모드에서 커널모드 진입

### 13
듀얼모드 연산
- 하드웨어적인 지원 -> 상태레지스터의 비트로 모드 결정
x86 
- 2개의 비트 사용 
- 링 네개를 만들 수 있다
- 대부분의 리눅스에선 링0(커널)과 링3(권한 가장 적은 사용자 모드) 사용 -> 링1,2는 일반적으로 사용하지 않는다

### 14
오류프로그램과 악의적인 프로그램의 동작
- 하드웨어적인 보호기법으로 차단 가능
커널 모드 : 하드웨어 직접적으로 통제 가능
사용자 모드 : 권한 낮다 -> 일부 명령어는 사용 불가
인터럽트와 폴트로 커널 진입 가능 
- 시스템콜같은 것이 끝나면 다시 유저모드로 복귀
- 리셋도 커널모드, 인터럽트

### 15
커널모드
- 하드웨어에 대한 충분한 접근 가능
- 어떤 기능은 유저에선 안된다
- 하드웨어아 직접적인 상호작용
- 굉장히 중요
- 많은 사용자 프로그램이 커널을 필요로함
- 입력과 출력 등 많은 일이 하드웨어로 필요로함 -> 빨리 많은 일을 처리해야함
- 부팅할 때 올라감
유저모드
- 할 수 있는 일들이 제한
- 특권 명령 불가
- 하드웨어 직접 접근 불가
- 커널 코드하고 분리

### 16
특권 명령
- 메모리매핑 변경
어떤 메모리 영역, IO공간은 커널모드에서만 접근
임계영역에 대한 핸들링
커널 데이터구조를 관리
- IVT - 인터럽트 벡터 테이블
- 페이지 테이블 : 가상주소를 물리주소로 매핑
32비트일 때 
- 커널이 1기가 정도
- 사용자는 3기가 정도

### 17
커널
- 커널코드와 데이터
- 물리 메모리
- 커널 테이블, 페이지 테이블, PCB : 프로레스마다 따로따로

### 18
하드웨어 접근 필요
- 커널에게 도움 요청 -> 시스템 콜 -> 트랩 -> 모드전이 -> modebit = 0 -> 시스템이 요청 처리 -> 끝나면 모드 비트 1 -> 사용자 모드로 리턴

### 19
사용자 프로그램이 시스템 콜 -> 트랩 -> 모드 전이
오류 발생 -> 폴트 -> 모드 전이
하드웨어에 입출력 요청 -> 해당 프로세스는 러닝에서 웨잇으로 바뀜 -> 입출력이 끝나면 인터럽트로 완료를 알림(아이오 인터럽트) -> 하던일 그만두고 커널로 진입
타임쉐어링, 라운드로빈에서 타임아웃 -> 타임 인터럽트 -> 커널모드 진입

### 20
시스템콜
- 의도적
- 하드웨어 직접 접근 불가 -> 사용자 프로그램이 커널에게 도움을 받아야됨
- 원하는 시점에 한다 -> 동기적
폴트
- 잘못된 주소에 접근, 보호주소 접근, 명령이 아닌데 실행 요쳥, 오버 플로우, 메모리에 없는 것 찾조 -> 세그멘테이션 바이올레이션, 폴트 -> 비의도적
- 명환한 이유가 존재 -> 동기적
- 비의도
인터럽트
- 의도없음
- 언제발생할지 모름 -> 비동기